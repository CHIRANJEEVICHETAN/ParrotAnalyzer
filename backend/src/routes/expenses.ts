import express, { Response, NextFunction } from 'express';
import { pool } from '../config/database';
import { verifyToken } from '../middleware/auth';
import { CustomRequest } from '../types';
import multer from 'multer';
import { PoolClient } from 'pg';
import NotificationService from "../services/notificationService";

const router = express.Router();

// Configure multer for memory storage
const upload = multer({
  storage: multer.memoryStorage(), // Store files in memory
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  },
  fileFilter: function (req, file, cb) {
    // Accept images and PDFs only
    if (!file.originalname.match(/\.(jpg|jpeg|png|pdf)$/)) {
      return cb(new Error("Only image and PDF files are allowed!"));
    }
    cb(null, true);
  },
});

// Add this function at the top of the file
const createNotification = async (
  client: PoolClient,
  userId: number,
  title: string,
  message: string,
  type: string,
  expenseDetails?: any
) => {
  try {
    // Create in-app notification
    await NotificationService.createInAppNotification(
      userId,
      title,
      message,
      type
    );

    // Format the notification message with emojis and details
    const formattedAmount = new Intl.NumberFormat("en-IN", {
      style: "currency",
      currency: "INR",
    }).format(expenseDetails.total_amount);

    const formattedDate = new Date(expenseDetails.date).toLocaleDateString();

    const notificationTitle =
      type === "approval"
        ? "ðŸ’° Expense Report Approved"
        : "âŒ Expense Report Rejected";

    const notificationMessage =
      `Your expense report has been ${
        type === "approval" ? "APPROVED âœ¨" : "REJECTED âš ï¸"
      }\n` +
      `ðŸ“Š EXPENSE DETAILS\n` +
      `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
      `ðŸ’µ Amount:     ${formattedAmount}\n` +
      `ðŸ—“ï¸ Date:       ${formattedDate}\n` +
      `ðŸš— Distance:   ${expenseDetails.total_kilometers}km\n` +
      `ðŸ“ Route:      ${expenseDetails.route_taken}\n` +
      (expenseDetails.comments
        ? `ðŸ“ Rejection Reason:   ${expenseDetails.comments}\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`
        : `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);

    // Send push notification using NotificationService
    await NotificationService.sendPushNotification(
      {
        id: 0, // This will be generated by the database
        user_id: userId.toString(),
        title: notificationTitle,
        message: notificationMessage,
        type: "expense-status",
        priority: "high",
        data: {
          screen: "/(dashboard)/employee/myExpenses",
          expenseId: expenseDetails.id,
          status: type === "approval" ? "approved" : "rejected",
          amount: expenseDetails.total_amount,
          date: expenseDetails.date,
          route: expenseDetails.route_taken,
          reason: expenseDetails.comments,
        },
      },
      [userId.toString()]
    );
  } catch (error) {
    console.error("Error in createNotification:", error);
    // Don't throw the error to prevent transaction rollback
    // Just log it since notification failure shouldn't fail the expense approval
  }
};

// Add this helper function at the top of the file
const parseNumericField = (value: string | undefined | null): number => {
  if (!value || value.trim() === "") return 0;
  const num = parseFloat(value);
  return isNaN(num) ? 0 : num;
};

// Place the employee specific route BEFORE other routes
// Add this route at the beginning of the file, right after creating the router
router.get(
  "/employee/my-expenses",
  verifyToken,
  async (req: CustomRequest, res: Response) => {
    const client = await pool.connect();
    try {
      console.log("Accessing employee my-expenses route with user:", {
        id: req.user?.id,
        role: req.user?.role,
      });

      if (!req.user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      // First check if the user has any expenses
      const checkQuery = await client.query(
        "SELECT COUNT(*) FROM expenses WHERE user_id = $1",
        [req.user.id]
      );

      console.log("Found expenses count:", checkQuery.rows[0].count);

      const result = await client.query(
        `SELECT 
        id,
        date,
        total_amount,
        amount_payable,
        status,
        rejection_reason,
        created_at,
        vehicle_type,
        vehicle_number,
        total_kilometers,
        route_taken,
        lodging_expenses,
        daily_allowance,
        diesel,
        toll_charges,
        other_expenses,
        advance_taken
      FROM expenses
      WHERE user_id = $1
      ORDER BY created_at DESC`,
        [req.user.id]
      );

      console.log("Query results:", {
        rowCount: result.rowCount,
        firstRow: result.rows[0] || null,
      });

      res.json(result.rows);
    } catch (error) {
      console.error("Detailed error in employee expenses:", error);
      res.status(500).json({
        error: "Failed to fetch expenses",
        details: error instanceof Error ? error.message : "Unknown error",
      });
    } finally {
      client.release();
    }
  }
);

// Group Admin routes should come first
router.get(
  "/group-admin/expenses",
  verifyToken,
  async (req: CustomRequest, res: Response) => {
    const client = await pool.connect();
    try {
      console.log("Accessing group-admin expenses route with user:", {
        id: req.user?.id,
        role: req.user?.role,
      });

      if (!req.user) {
        return res.status(401).json({
          error: "Authentication required",
          details: "No user found in request",
        });
      }

      if (req.user.role !== "group-admin") {
        return res.status(403).json({
          error: "Access denied",
          details: `Only group admins can access this resource. Your role is: ${req.user.role}`,
        });
      }

      const result = await client.query(
        `
      SELECT 
        e.id,
        e.date,
        CAST(e.total_amount AS FLOAT) as total_amount,
        CAST(e.amount_payable AS FLOAT) as amount_payable,
        e.status,
        CASE 
          WHEN e.status = 'approved' THEN true
          WHEN e.status = 'rejected' THEN false
          ELSE null
        END as group_admin_approved,
        false as management_approved,
        u.name as employee_name,
        u.employee_number,
        u.department
      FROM expenses e
      JOIN users u ON e.user_id = u.id
      WHERE u.group_admin_id = $1
      ORDER BY e.created_at DESC`,
        [req.user.id]
      );

      console.log("Query results:", {
        rowCount: result.rowCount,
        firstRow: result.rows[0],
      });

      res.json(result.rows);
    } catch (error) {
      console.error("Error in group-admin expenses:", error);
      res.status(500).json({
        error: "Failed to fetch expenses",
        details:
          error instanceof Error ? error.message : "Unknown error occurred",
      });
    } finally {
      client.release();
    }
  }
);

// Group Admin approval route
router.post(
  "/group-admin/:id/approve",
  verifyToken,
  async (req: CustomRequest, res: Response) => {
    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      if (req.user?.role !== "group-admin") {
        return res.status(403).json({ error: "Access denied" });
      }

      const { id } = req.params;
      const { approved, comments = "" } = req.body;

      // First get the expense details including user_id
      const expenseResult = await client.query(
        `SELECT e.*, u.name as employee_name, u.id as user_id
         FROM expenses e 
         JOIN users u ON e.user_id = u.id 
         WHERE e.id = $1`,
        [id]
      );

      if (expenseResult.rows.length === 0) {
        return res.status(404).json({ error: "Expense not found" });
      }

      const expense = expenseResult.rows[0];

      // Update the expense status
      const result = await client.query(
        `UPDATE expenses 
         SET status = $1,
             comments = $2,
             updated_at = CURRENT_TIMESTAMP
         WHERE id = $3 AND EXISTS (
           SELECT 1 FROM users 
           WHERE id = expenses.user_id 
           AND group_admin_id = $4
         )
        RETURNING *`,
        [approved ? "approved" : "rejected", comments || null, id, req.user.id]
      );

      if (result.rows.length === 0) {
        throw new Error("Failed to update expense");
      }

      // Send notification with enhanced details
      await createNotification(
        client,
        expense.user_id,
        approved ? "âœ… Expense Approved" : "âŒ Expense Rejected",
        "", // Message will be formatted inside createNotification
        approved ? "approval" : "rejection",
        {
          ...expense,
          comments,
          id: expense.id,
          total_amount: expense.total_amount,
          date: expense.date,
          route_taken: expense.route_taken,
          total_kilometers: expense.total_kilometers,
        }
      );

      await client.query("COMMIT");
      res.json(result.rows[0]);
    } catch (error) {
      await client.query("ROLLBACK");
      console.error("Error in expense approval:", error);
      res.status(500).json({
        error: "Failed to process expense",
        details:
          error instanceof Error ? error.message : "Unknown error occurred",
      });
    } finally {
      client.release();
    }
  }
);

// Group Admin report routes
router.get('/group-admin/reports/expenses/summary', verifyToken, async (req: CustomRequest, res: Response) => {
  const client = await pool.connect();
  try {
    if (req.user?.role !== 'group-admin') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const result = await client.query(`
      WITH employee_expenses AS (
        SELECT e.*
       FROM expenses e
       JOIN users u ON e.user_id = u.id
       WHERE u.group_admin_id = $1
      )
      SELECT 
        CAST(COALESCE(SUM(total_amount), 0) AS FLOAT) as total_amount,
        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
        COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_count,
        COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_count
      FROM employee_expenses`,
      [req.user.id]
    );

    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching expense summary:', error);
    res.status(500).json({ error: 'Failed to fetch expense summary' });
  } finally {
    client.release();
  }
});

router.get('/group-admin/reports/expenses/by-employee', verifyToken, async (req: CustomRequest, res: Response) => {
  const client = await pool.connect();
  try {
    if (req.user?.role !== 'group-admin') {
      return res.status(403).json({ error: 'Access denied' });
    }

    const result = await client.query(`
      SELECT 
        u.name as employee_name, 
        CAST(COALESCE(SUM(e.total_amount), 0) AS FLOAT) as total_expenses,
        COUNT(CASE WHEN e.status = 'approved' THEN 1 END) as approved_count,
        COUNT(CASE WHEN e.status = 'rejected' THEN 1 END) as rejected_count
      FROM users u
      LEFT JOIN expenses e ON e.user_id = u.id
      WHERE u.group_admin_id = $1
      AND u.role = 'employee'
      GROUP BY u.id, u.name
      ORDER BY total_expenses DESC`,
      [req.user.id]
    );

    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching employee expense report:', error);
    res.status(500).json({ error: 'Failed to fetch employee expense report' });
  } finally {
    client.release();
  }
});

// Update the expense submission route
router.post(
  "/submit",
  verifyToken,
  upload.array("documents"),
  async (req: CustomRequest, res: Response) => {
    const client = await pool.connect();
    try {
      console.log("Starting expense submission process...");
      console.log("Request body:", req.body);

      // Validate required employee details
      const requiredFields = [
        "employeeName",
        "employeeNumber",
        "department",
        "designation",
      ];
      const missingFields = requiredFields.filter((field) => !req.body[field]);

      if (missingFields.length > 0) {
        return res.status(400).json({
          error: "Missing required fields",
          details: `Missing fields: ${missingFields.join(", ")}`,
        });
      }

      if (req.user?.role !== "employee") {
        return res
          .status(403)
          .json({ error: "Only employees can submit expenses" });
      }

      await client.query("BEGIN");

      // Get user's company_id, active shift, and permissions
      const userResult = await client.query(
        "SELECT company_id, can_submit_expenses_anytime FROM users WHERE id = $1",
        [req.user.id]
      );
      const company_id = userResult.rows[0]?.company_id;
      const canSubmitAnytime =
        userResult.rows[0]?.can_submit_expenses_anytime || false;

      // Always check for active shift, even if user can submit anytime
      // This way we can update the shift with kilometers and expenses if it exists
      let activeShift = null;
      const activeShiftResult = await client.query(
        `SELECT id, total_expenses, total_kilometers
         FROM employee_shifts 
         WHERE user_id = $1 
         AND status = 'active' 
         ORDER BY start_time DESC 
         LIMIT 1`,
        [req.user.id]
      );
      
      if (activeShiftResult.rows.length > 0) {
        activeShift = activeShiftResult.rows[0];
        console.log("Found active shift:", activeShift);
      } else if (!canSubmitAnytime) {
        // Only prevent submission if user cannot submit anytime
        await client.query("ROLLBACK");
        return res.status(400).json({
          error: "No active shift found",
          details: "You must have an active shift to submit expenses",
        });
      }

      // First, ensure user details are up to date
      await client.query(
        `
      UPDATE users 
      SET 
        name = $1,
        employee_number = $2,
        department = $3,
        designation = $4
      WHERE id = $5`,
        [
          req.body.employeeName,
          req.body.employeeNumber,
          req.body.department,
          req.body.designation,
          req.user.id,
        ]
      );

      // Get saved travel and expense details from request
      const savedTravelDetails = JSON.parse(
        req.body.savedTravelDetails || "[]"
      );
      const savedExpenseDetails = JSON.parse(
        req.body.savedExpenseDetails || "[]"
      );

      // Combine current form data with saved details
      const allTravelDetails = [
        ...savedTravelDetails,
        {
          vehicleType: req.body.vehicleType,
          vehicleNumber: req.body.vehicleNumber,
          totalKilometers: req.body.totalKilometers,
          startDateTime: req.body.startDateTime,
          endDateTime: req.body.endDateTime,
          routeTaken: req.body.routeTaken,
        },
      ].filter((detail) => detail.vehicleType && detail.totalKilometers);

      const allExpenseDetails = [
        ...savedExpenseDetails,
        {
          lodgingExpenses: req.body.lodgingExpenses,
          dailyAllowance: req.body.dailyAllowance,
          diesel: req.body.diesel,
          tollCharges: req.body.tollCharges,
          otherExpenses: req.body.otherExpenses,
        },
      ].filter(
        (detail) =>
          detail.lodgingExpenses ||
          detail.dailyAllowance ||
          detail.diesel ||
          detail.tollCharges ||
          detail.otherExpenses
      );

      let totalExpensesForShift = 0;
      let totalKilometersForShift = 0;

      // Insert an expense record for each travel detail
      for (const travelDetail of allTravelDetails) {
        const expenseDetail = allExpenseDetails[
          allTravelDetails.indexOf(travelDetail)
        ] || {
          lodgingExpenses: 0,
          dailyAllowance: 0,
          diesel: 0,
          tollCharges: 0,
          otherExpenses: 0,
        };

        const totalAmount =
          Number(expenseDetail.lodgingExpenses || 0) +
          Number(expenseDetail.dailyAllowance || 0) +
          Number(expenseDetail.diesel || 0) +
          Number(expenseDetail.tollCharges || 0) +
          Number(expenseDetail.otherExpenses || 0);

        totalExpensesForShift += totalAmount;
        totalKilometersForShift += parseNumericField(travelDetail.totalKilometers);

        const amountPayable = totalAmount - Number(req.body.advanceTaken || 0);

        const expenseResult = await client.query(
          `
        INSERT INTO expenses (
          user_id, company_id, employee_name, employee_number, department, designation,
          location, date, vehicle_type, vehicle_number, total_kilometers,
          start_time, end_time, route_taken, lodging_expenses, daily_allowance,
          diesel, toll_charges, other_expenses, advance_taken, total_amount,
          amount_payable, status, created_at, updated_at, shift_id
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, 
          $16, $17, $18, $19, $20, $21, $22, 'pending', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, $23
        ) RETURNING id`,
          [
            req.user.id,
            company_id,
            req.body.employeeName,
            req.body.employeeNumber,
            req.body.department,
            req.body.designation,
            req.body.location,
            new Date(req.body.date),
            travelDetail.vehicleType,
            travelDetail.vehicleNumber,
            travelDetail.totalKilometers,
            new Date(travelDetail.startDateTime),
            new Date(travelDetail.endDateTime),
            travelDetail.routeTaken,
            expenseDetail.lodgingExpenses || 0,
            expenseDetail.dailyAllowance || 0,
            expenseDetail.diesel || 0,
            expenseDetail.tollCharges || 0,
            expenseDetail.otherExpenses || 0,
            req.body.advanceTaken || 0,
            totalAmount,
            amountPayable,
            activeShift?.id || null, // Use null if no active shift (when canSubmitAnytime is true)
          ]
        );

        const expenseId = expenseResult.rows[0].id;

        // Handle document uploads if any
        if (req.files && Array.isArray(req.files)) {
          for (const file of req.files) {
            await client.query(
              `
            INSERT INTO expense_documents (
              expense_id, file_name, file_type, file_size, file_data
            ) VALUES ($1, $2, $3, $4, $5)`,
              [
                expenseId,
                file.originalname,
                file.mimetype,
                file.size,
                file.buffer,
              ]
            );
          }
        }
      }

      // Update total_expenses and total_kilometers in employee_shifts table if there's an active shift
      // This now happens regardless of the canSubmitAnytime permission
      if (activeShift) {
        console.log("Updating active shift with new totals:", {
          shiftId: activeShift.id,
          currentExpenses: activeShift.total_expenses,
          newExpenses: totalExpensesForShift,
          currentKilometers: activeShift.total_kilometers,
          newKilometers: totalKilometersForShift
        });
        
        const currentTotalExpenses =
          parseFloat(activeShift.total_expenses) || 0;
        const newTotalExpenses = currentTotalExpenses + totalExpensesForShift;
        
        const currentTotalKilometers =
          parseFloat(activeShift.total_kilometers) || 0;
        const newTotalKilometers = currentTotalKilometers + totalKilometersForShift;
        
        await client.query(
          `UPDATE employee_shifts 
         SET total_expenses = $1,
             total_kilometers = $2,
             updated_at = CURRENT_TIMESTAMP 
         WHERE id = $3`,
          [newTotalExpenses, newTotalKilometers, activeShift.id]
        );
      }

      await client.query("COMMIT");
      console.log("Expense submission completed successfully");
      res.json({
        message: "Expense submitted successfully",
        shiftId: activeShift?.id || null,
        totalExpenses: activeShift
          ? parseFloat(activeShift.total_expenses) + totalExpensesForShift
          : totalExpensesForShift,
        totalKilometers: activeShift
          ? parseFloat(activeShift.total_kilometers) + totalKilometersForShift
          : totalKilometersForShift,
        submittedWithoutShift: canSubmitAnytime && !activeShift,
      });
    } catch (error) {
      await client.query("ROLLBACK");
      console.error("Error in expense submission:", error);
      res.status(500).json({
        error: "Failed to submit expense",
        details:
          error instanceof Error ? error.message : "Unknown error occurred",
      });
    } finally {
      client.release();
    }
  }
);

// Finally add the generic routes
router.get("/:id", verifyToken, async (req: CustomRequest, res: Response) => {
  const client = await pool.connect();
  try {
    console.log("Fetching expense details for ID:", req.params.id);

    if (!req.user) {
      return res.status(401).json({ error: "Authentication required" });
    }

    // Query to get expense details with employee information
    const result = await client.query(
      `
      SELECT 
        e.*,
        u.name as employee_name,
        u.employee_number,
        u.department,
        u.designation
      FROM expenses e
      JOIN users u ON e.user_id = u.id
      WHERE e.id = $1
      AND (
        -- Allow access if user is the group admin of the employee
        (
          $2 = 'group-admin' 
          AND u.group_admin_id = $3
        )
        -- Or if user is management
        OR $2 = 'management'
        -- Or if user is the employee who submitted the expense
        OR (
          $2 = 'employee' 
          AND e.user_id = $3
        )
      )`,
      [req.params.id, req.user.role, req.user.id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        error: "Expense not found",
        details:
          "The expense does not exist or you do not have permission to view it",
      });
    }

    // Convert numeric fields to ensure they're numbers
    const expense = result.rows[0];
    const numericFields = [
      "total_amount",
      "amount_payable",
      "lodging_expenses",
      "daily_allowance",
      "diesel",
      "toll_charges",
      "other_expenses",
      "advance_taken",
      "total_kilometers",
    ];

    numericFields.forEach((field) => {
      if (expense[field]) {
        expense[field] = parseFloat(expense[field]);
      }
    });

    console.log("Expense details found:", {
      id: expense.id,
      employee: expense.employee_name,
      status: expense.status,
    });

    res.json(expense);
  } catch (error) {
    console.error("Error fetching expense details:", error);
    res.status(500).json({
      error: "Failed to fetch expense details",
      details:
        error instanceof Error ? error.message : "Unknown error occurred",
    });
  } finally {
    client.release();
  }
});

// Add this route to fetch documents for an expense
router.get(
  "/:id/documents",
  verifyToken,
  async (req: CustomRequest, res: Response) => {
    const client = await pool.connect();
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Authentication required" });
      }

      // First check if user has access to this expense
      const accessCheck = await client.query(
        `
      SELECT 1
       FROM expenses e
       JOIN users u ON e.user_id = u.id
      WHERE e.id = $1
      AND (
        (
          $2 = 'group-admin' 
          AND u.group_admin_id = $3
        )
        OR $2 = 'management'
        OR (
          $2 = 'employee' 
          AND e.user_id = $3
        )
      )`,
        [req.params.id, req.user.role, req.user.id]
      );

      if (accessCheck.rows.length === 0) {
        return res.status(403).json({
          error: "Access denied",
          details: "You do not have permission to view these documents",
        });
      }

      // Fetch documents
      const result = await client.query(
        `
      SELECT 
        id,
        file_name,
        file_type,
        file_size,
        file_data,
        created_at
      FROM expense_documents
      WHERE expense_id = $1
      ORDER BY created_at DESC`,
        [req.params.id]
      );

      // Convert binary data to base64
      const documents = result.rows.map((doc) => ({
        ...doc,
        file_data: doc.file_data.toString("base64"),
      }));

      res.json(documents);
    } catch (error) {
      console.error("Error fetching expense documents:", error);
      res.status(500).json({
        error: "Failed to fetch documents",
        details:
          error instanceof Error ? error.message : "Unknown error occurred",
      });
    } finally {
      client.release();
    }
  }
);

export default router;